<html>

<head>
<title>Learning WebGL &mdash; lesson 14</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform float uMaterialShininess;

    uniform bool uShowSpecularHighlights;
    uniform bool uUseLighting;
    uniform bool uUseTextures;

    uniform vec3 uAmbientColor;

    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingSpecularColor;
    uniform vec3 uPointLightingDiffuseColor;

    uniform sampler2D uSampler;
uniform sampler2D u_image0;
uniform sampler2D u_image1;

    void main(void) {
        vec3 lightWeighting;
        if (!uUseLighting) {
            lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
            vec3 normal = normalize(vTransformedNormal);

            float specularLightWeighting = 0.0;
            if (uShowSpecularHighlights) {
                vec3 eyeDirection = normalize(-vPosition.xyz);
                vec3 reflectionDirection = reflect(-lightDirection, normal);

                specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
            }

            float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
            lightWeighting = uAmbientColor
                + uPointLightingSpecularColor * specularLightWeighting
                + uPointLightingDiffuseColor * diffuseLightWeighting;
        }
        vec4 fragmentColor;
       // if (uUseTextures) {
            fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        //} else {
           // fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
        //}
        gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);
		//        gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

    }
</script>

<script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;


    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "per-fragment-lighting-fs");
        var vertexShader = getShader(gl, "per-fragment-lighting-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
        shaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(shaderProgram, "uShowSpecularHighlights");
        shaderProgram.useTexturesUniform = gl.getUniformLocation(shaderProgram, "uUseTextures");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
        shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
        shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
    }


    function handleLoadedTexture(textures) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		//window.alert(textures[2].image.src);

        gl.bindTexture(gl.TEXTURE_2D, textures[0]); //cement 
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[0].image);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);		
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);

		   gl.bindTexture(gl.TEXTURE_2D, textures[1]);//grass
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[1].image);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		
        gl.bindTexture(gl.TEXTURE_2D, textures[2]);//crate
       gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[2].image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);

		gl.bindTexture(gl.TEXTURE_2D, textures[3]);//metal
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[3].image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						gl.generateMipmap(gl.TEXTURE_2D);


				
			gl.bindTexture(gl.TEXTURE_2D, textures[4]);//wood
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[4].image);       
	   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		
		
			gl.bindTexture(gl.TEXTURE_2D, textures[5]);//red
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[5].image);       
	   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		
			gl.bindTexture(gl.TEXTURE_2D, textures[6]);//robot
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[6].image);       
	   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);		
		
			gl.bindTexture(gl.TEXTURE_2D, textures[7]);//blue
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[7].image);       
	   //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.generateMipmap(gl.TEXTURE_2D);
		
        gl.bindTexture(gl.TEXTURE_2D, null);
    }


    var galvanizedTexture;
    var crateTextures = Array();

    function initTextures() {
     

       

    
	 var crateImage = new Image();
		var floor  = new Image();
		var crate  = new Image();
    	var wood  = new Image();
		var red  = new Image();
		var robot  = new Image();
		var sky  = new Image();


	
            var texture = gl.createTexture();
		
		   texture.image = crateImage;
		   crateImage.src = "cement.jpg";
		   crateTextures.push(texture);

			
			var tx1 = gl.createTexture();
			tx1.image = floor;
			floor.src = "grass1.png";
            crateTextures.push(tx1);

			var tx2 = gl.createTexture();
			tx2.image = crate;
			crate.src = "crate.jpg";
            crateTextures.push(tx2);
			
			var tx3 = gl.createTexture();
			tx3.image = wood;
			wood.src = "wood.jpg";
            crateTextures.push(tx3);
			
	
			
			
		galvanizedTexture = gl.createTexture();
        galvanizedTexture.image = new Image();
       
        galvanizedTexture.image.src = "arroway.de_metal+structure+06_d100_flat.jpg";
         crateTextures.push(galvanizedTexture);
			
			var tx4 = gl.createTexture();
			tx4.image = red;
			red.src = "red.jpg";
            crateTextures.push(tx4);
			
			var tx5 = gl.createTexture();
			tx5.image = robot;
			robot.src = "robot.jpg";
            crateTextures.push(tx5);
			
			var tx6 = gl.createTexture();
			tx6.image = sky;
			sky.src = "sky.jpg";
            crateTextures.push(tx6);
			
			crateImage.onload = function () {
            handleLoadedTexture(crateTextures)
        }
	
	
	}


    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

	
	
    var zRot = 0;
    var zDir = 0;

    var yRot = 0;
    var xDir = 0;

    var z = -5.0;

    var filter = 0;
	var orbit = false;
	var walk1 = false;
	var walk2 = false;
	var rotate = 0;
	var pan = 0;
	var k1 = false;
	var k2 = false;
	var k3 = false;
	var k4 = false;
	var rot = 0;
    var currentlyPressedKeys = {};
	switch1 =false;
	switch2 =false;
	  var mouseDown = false;
  var lastMouseX = null;
  var lastMouseY = null;
	var top = false;
	var t = 0;

  function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;


  }

  function handleMouseUp(event) {
    mouseDown = false;
  }

	
	
	
	
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;

      
    }


    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }
function reply_click(clicked_id)
{
    rot +=90;
}
function reply_click1(clicked_id)
{
	if(Boolean(switch1) == false){
	switch1 =true;
	}
    else{
	switch1 =false;
	}
}
function reply_click2(clicked_id)
{
    if(Boolean(switch2) == false){
	switch2 =true;
	}
    else{
	switch2 =false;
	}
}

var y = -10;
var x = 0;

    function handleKeys() {
	if (currentlyPressedKeys[65]) {
           //a - move left
		   x -= .5;
        }
			if (currentlyPressedKeys[87]) {
           //w - move forward
		   y -= .5;
        }
			if (currentlyPressedKeys[68]) {
           //d - move right
		   x += .5;
        }
			if (currentlyPressedKeys[83]) {
           //s - move back
		   y += .5;
        }
		if (currentlyPressedKeys[66]) {
            // 2 //move view
            //yRot = 90;
			if(Boolean(top) == false){
			top =true;
			t=90;
			}
			else{
			top =false;
			t=0;
			}
			
        }
		if (currentlyPressedKeys[51]) {
            // 3 //move view
            k3 = true;
        }
		if (currentlyPressedKeys[52]) {
            // 4 //move view
           k4 = true;
        }
	if (currentlyPressedKeys[69]) {
            // q
            walk1 = true;
			walk2 = false;
        }
        if (currentlyPressedKeys[82]) {
            // w
            walk1 = false;
			walk2 = true;
        }
	 if (currentlyPressedKeys[75]) {
            // k
            pan -= .25
        }
        if (currentlyPressedKeys[77]) {
            // m
            pan += .25
        }
        if (currentlyPressedKeys[33]) {
            // Page Up
            orbit = true;
			rotate += 5;
        }
        if (currentlyPressedKeys[34]) {
            // Page Down
            z += 0.05;
        }
        if (currentlyPressedKeys[37]) {
            // Left cursor key
            xDir += .25;
        }
        if (currentlyPressedKeys[39]) {
            // Right cursor key
            xDir -= .25;
        }
        if (currentlyPressedKeys[38]) {
            // Up cursor key
            zDir += .25;
        }
        if (currentlyPressedKeys[40]) {
            // Down cursor key
            zDir -= .25;
        }
    }
	
	
	var cubeVertexPositionBuffer;
    var cubeVertexTextureCoordBuffer;
    var squareVertexTextureCoordBuffer;

    var cubeVertexIndexBuffer;
    function initBuffers() {
	
	squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
	
	floorVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        floorVertexPositionBuffer.itemSize = 3;
        floorVertexPositionBuffer.numItems = 4;
	
	vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
   
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    vertexPositionBuffer.itemSize = 2;
    vertexPositionBuffer.numItems = 4;
	
	
        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ];
		
	
		
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
		
		
		
        var textureCoords = [
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,

            // Back face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Top face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,

            // Bottom face
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,

            // Right face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Left face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;
	
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ]
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;
		
		
		squareVertexTextureCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);


		 var sqtextureCoords = [
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sqtextureCoords), gl.STATIC_DRAW);
			squareVertexTextureCoordBuffer.itemSize = 2;
			squareVertexTextureCoordBuffer.numItems = 4;
		
		
		
    }

    var teapotVertexPositionBuffer;
    var teapotVertexNormalBuffer;
    var teapotVertexTextureCoordBuffer;
    var teapotVertexIndexBuffer;

    function handleLoadedTeapot(teapotData) {
        teapotVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
        teapotVertexNormalBuffer.itemSize = 3;
        teapotVertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

        teapotVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexTextureCoords), gl.STATIC_DRAW);
        teapotVertexTextureCoordBuffer.itemSize = 2;
        teapotVertexTextureCoordBuffer.numItems = teapotData.vertexTextureCoords.length / 2;

        teapotVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
        teapotVertexPositionBuffer.itemSize = 3;
        teapotVertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

        teapotVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(teapotData.indices), gl.STATIC_DRAW);
        teapotVertexIndexBuffer.itemSize = 1;
        teapotVertexIndexBuffer.numItems = teapotData.indices.length;

        document.getElementById("loadingtext").textContent = "";
    }


	var laptopVertexPositionBuffer;
    var laptopVertexNormalBuffer;
    var laptopVertexTextureCoordBuffer;
    var laptopVertexIndexBuffer;
	function handleLoadedLaptop(laptopData) {
	//window.alert("wrong");
        laptopVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(laptopData.vertexNormals), gl.STATIC_DRAW);
        laptopVertexNormalBuffer.itemSize = 3;
        laptopVertexNormalBuffer.numItems = laptopData.vertexNormals.length / 3;

        laptopVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(laptopData.vertexTextureCoords), gl.STATIC_DRAW);
        laptopVertexTextureCoordBuffer.itemSize = 2;
        laptopVertexTextureCoordBuffer.numItems = laptopData.vertexTextureCoords.length / 2;

        laptopVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(laptopData.vertexPositions), gl.STATIC_DRAW);
        laptopVertexPositionBuffer.itemSize = 3;
        laptopVertexPositionBuffer.numItems = laptopData.vertexPositions.length / 3;

        laptopVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, laptopVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(laptopData.indices), gl.STREAM_DRAW);
        laptopVertexIndexBuffer.itemSize = 1;
        laptopVertexIndexBuffer.numItems = laptopData.indices.length;
    }

	var HouseVertexPositionBuffer;
    var HouseVertexNormalBuffer;
    var HouseVertexTextureCoordBuffer;
    var HouseVertexIndexBuffer;
	function handleLoadedHouse(HouseData) {
	//window.alert("wrong");
        HouseVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(HouseData.normals), gl.STATIC_DRAW);
        HouseVertexNormalBuffer.itemSize = 3;
        HouseVertexNormalBuffer.numItems = HouseData.normals.length / 3;

        HouseVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(HouseData.texcoords), gl.STATIC_DRAW);
        HouseVertexTextureCoordBuffer.itemSize = 2;
        HouseVertexTextureCoordBuffer.numItems = HouseData.texcoords.length / 2;

        HouseVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(HouseData.verts), gl.STATIC_DRAW);
        HouseVertexPositionBuffer.itemSize = 3;
        HouseVertexPositionBuffer.numItems = HouseData.verts.length / 3;

        HouseVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, HouseVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(HouseData.indices), gl.STREAM_DRAW);
        HouseVertexIndexBuffer.itemSize = 1;
        HouseVertexIndexBuffer.numItems = HouseData.indices.length;
    }
	
	var faceVertexPositionBuffer;
    var faceVertexNormalBuffer;
    var faceVertexTextureCoordBuffer;
    var faceVertexIndexBuffer;
	function handleLoadedface(faceData) {
	//window.alert("wrong");
        faceVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceData.normals), gl.STATIC_DRAW);
        faceVertexNormalBuffer.itemSize = 3;
        faceVertexNormalBuffer.numItems = faceData.normals.length / 3;

        faceVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceData.texcoords), gl.STATIC_DRAW);
        faceVertexTextureCoordBuffer.itemSize = 2;
        faceVertexTextureCoordBuffer.numItems = faceData.texcoords.length / 2;

        faceVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceData.verts), gl.STATIC_DRAW);
        faceVertexPositionBuffer.itemSize = 3;
        faceVertexPositionBuffer.numItems = faceData.verts.length / 3;

        faceVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(faceData.indices), gl.STREAM_DRAW);
        faceVertexIndexBuffer.itemSize = 1;
        faceVertexIndexBuffer.numItems = faceData.indices.length;
    }
	
		var face2VertexPositionBuffer;
    var face2VertexNormalBuffer;
    var face2VertexTextureCoordBuffer;
    var face2VertexIndexBuffer;
	function handleLoadedface2(face2Data) {
	//window.alert("wrong");
        face2VertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face2Data.normals), gl.STATIC_DRAW);
        face2VertexNormalBuffer.itemSize = 3;
        face2VertexNormalBuffer.numItems = face2Data.normals.length / 3;

        face2VertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face2Data.texcoords), gl.STATIC_DRAW);
        face2VertexTextureCoordBuffer.itemSize = 2;
        face2VertexTextureCoordBuffer.numItems = face2Data.texcoords.length / 2;

        face2VertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face2Data.verts), gl.STATIC_DRAW);
        face2VertexPositionBuffer.itemSize = 3;
        face2VertexPositionBuffer.numItems = face2Data.verts.length / 3;

        face2VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, face2VertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(face2Data.indices), gl.STREAM_DRAW);
        face2VertexIndexBuffer.itemSize = 1;
        face2VertexIndexBuffer.numItems = face2Data.indices.length;
    }
		var face3VertexPositionBuffer;
    var face3VertexNormalBuffer;
    var face3VertexTextureCoordBuffer;
    var face3VertexIndexBuffer;
	function handleLoadedface3(face3Data) {
	//window.alert("wrong");
        face3VertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face3Data.normals), gl.STATIC_DRAW);
        face3VertexNormalBuffer.itemSize = 3;
        face3VertexNormalBuffer.numItems = face3Data.normals.length / 3;

        face3VertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face3Data.texcoords), gl.STATIC_DRAW);
        face3VertexTextureCoordBuffer.itemSize = 2;
        face3VertexTextureCoordBuffer.numItems = face3Data.texcoords.length / 2;

        face3VertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(face3Data.verts), gl.STATIC_DRAW);
        face3VertexPositionBuffer.itemSize = 3;
        face3VertexPositionBuffer.numItems = face3Data.verts.length / 3;

        face3VertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, face3VertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(face3Data.indices), gl.STREAM_DRAW);
        face3VertexIndexBuffer.itemSize = 1;
        face3VertexIndexBuffer.numItems = face3Data.indices.length;
    }
	
	
	
	
	var palletVertexPositionBuffer;
    var palletVertexNormalBuffer;
    var palletVertexTextureCoordBuffer;
    var palletVertexIndexBuffer;
	function handleLoadedpallet(palletData) {
	//window.alert("wrong");
        palletVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(palletData.normals), gl.STATIC_DRAW);
        palletVertexNormalBuffer.itemSize = 3;
        palletVertexNormalBuffer.numItems = palletData.normals.length / 3;

        palletVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(palletData.texcoords), gl.STATIC_DRAW);
        palletVertexTextureCoordBuffer.itemSize = 2;
        palletVertexTextureCoordBuffer.numItems = palletData.texcoords.length / 2;

        palletVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(palletData.verts), gl.STATIC_DRAW);
        palletVertexPositionBuffer.itemSize = 3;
        palletVertexPositionBuffer.numItems = palletData.verts.length / 3;

        palletVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, palletVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(palletData.indices), gl.STREAM_DRAW);
        palletVertexIndexBuffer.itemSize = 1;
        palletVertexIndexBuffer.numItems = palletData.indices.length;
    }
	
	var dinVertexPositionBuffer;
    var dinVertexNormalBuffer;
    var dinVertexTextureCoordBuffer;
    var dinVertexIndexBuffer;
	function handleLoadedDin(dinData) {
	//window.alert("wrong");
        dinVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dinData.normals), gl.STATIC_DRAW);
        dinVertexNormalBuffer.itemSize = 3;
        dinVertexNormalBuffer.numItems = dinData.normals.length / 3;

        dinVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dinData.texcoords), gl.STATIC_DRAW);
        dinVertexTextureCoordBuffer.itemSize = 2;
        dinVertexTextureCoordBuffer.numItems = dinData.texcoords.length / 2;

        dinVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dinData.verts), gl.STATIC_DRAW);
        dinVertexPositionBuffer.itemSize = 3;
        dinVertexPositionBuffer.numItems = dinData.verts.length / 3;

        dinVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dinVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dinData.indices), gl.STREAM_DRAW);
        dinVertexIndexBuffer.itemSize = 1;
        dinVertexIndexBuffer.numItems = dinData.indices.length;
    }
	
	
	var boatVertexPositionBuffer;
    var boatVertexNormalBuffer;
    var boatVertexTextureCoordBuffer;
    var boatVertexIndexBuffer;
	function handleLoadedboat(boatData) {
	//window.alert("wrong");
        boatVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boatData.normals), gl.STATIC_DRAW);
        boatVertexNormalBuffer.itemSize = 3;
        boatVertexNormalBuffer.numItems = boatData.normals.length / 3;

        boatVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boatData.texcoords), gl.STATIC_DRAW);
        boatVertexTextureCoordBuffer.itemSize = 2;
        boatVertexTextureCoordBuffer.numItems = boatData.texcoords.length / 2;

        boatVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boatData.verts), gl.STATIC_DRAW);
        boatVertexPositionBuffer.itemSize = 3;
        boatVertexPositionBuffer.numItems = boatData.verts.length / 3;

        boatVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boatVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boatData.indices), gl.STREAM_DRAW);
        boatVertexIndexBuffer.itemSize = 1;
        boatVertexIndexBuffer.numItems = boatData.indices.length;
    }
	
    function loadTeapot() {
        var request = new XMLHttpRequest();
        request.open("GET", "teapot.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedTeapot(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
    var teapotAngle = 0;
	function loadPallet() {
        var request = new XMLHttpRequest();
        request.open("GET", "pallet1.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedpallet(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	
	function loadDin() {
        var request = new XMLHttpRequest();
        request.open("GET", "din.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedDin(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	function loadboat() {
        var request = new XMLHttpRequest();
        request.open("GET", "boat.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedboat(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	
	 function loadLaptop() {
        var request = new XMLHttpRequest();
        request.open("GET", "macbook.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedLaptop(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	function loadHouse() {
        var request = new XMLHttpRequest();
        request.open("GET", "house.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedHouse(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
function loadface() {
        var request = new XMLHttpRequest();
        request.open("GET", "2faceBig.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedface(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	
function loadface2() {
        var request = new XMLHttpRequest();
        request.open("GET", "2face2.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedface2(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	
	function loadface3() {
        var request = new XMLHttpRequest();
        request.open("GET", "2face3.json");
		request.overrideMimeType("application/json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedface3(JSON.parse(request.responseText));
            }
        }
        request.send(null);
    }
	
	
	

    function drawScene() {
		document.getElementById("pos1").innerHTML = x;
	document.getElementById("pos2").innerHTML = y;
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        if (teapotVertexPositionBuffer == null || teapotVertexNormalBuffer == null || teapotVertexTextureCoordBuffer == null || teapotVertexIndexBuffer == null) {
           // window.alert("hi");
			return;
        }
     
    
			
			
			
        var specularHighlights = document.getElementById("specular").checked;
        gl.uniform1i(shaderProgram.showSpecularHighlightsUniform, specularHighlights);

        var lighting = document.getElementById("lighting").checked;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);
        if (lighting) {
            gl.uniform3f(
                shaderProgram.ambientColorUniform,
                parseFloat(document.getElementById("ambientR").value),
                parseFloat(document.getElementById("ambientG").value),
                parseFloat(document.getElementById("ambientB").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingLocationUniform,
                parseFloat(document.getElementById("lightPositionX").value),
                parseFloat(document.getElementById("lightPositionY").value),
                parseFloat(document.getElementById("lightPositionZ").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingSpecularColorUniform,
                parseFloat(document.getElementById("specularR").value),
                parseFloat(document.getElementById("specularG").value),
                parseFloat(document.getElementById("specularB").value)
            );

            gl.uniform3f(
                shaderProgram.pointLightingDiffuseColorUniform,
                parseFloat(document.getElementById("diffuseR").value),
                parseFloat(document.getElementById("diffuseG").value),
                parseFloat(document.getElementById("diffuseB").value)
            );
        }

   
	//start laptop
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
            
			
			return;
        }
			//window.alert(textures[2].image.src);

	
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	     mat4.identity(mvMatrix);
		 if(Boolean(k1) == true){
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		}
	
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		mat4.translate(mvMatrix, [xDir, pan, zDir]);
	
	
	
	//mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [-3, -9.5, -13]);
        mat4.rotate(mvMatrix, degToRad(-90), [1, 0, 0]);
		mat4.rotate(mvMatrix, degToRad(0), [0, 1, 0]);
    
		
			gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, laptopVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, laptopVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, laptopVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, laptopVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, laptopVertexIndexBuffer);
		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[1]);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, laptopVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	
	
	
	
	
	
	
	
	//end laptop
	
	
	
	
	//start house
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
            
			
			return;
        }
			mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
       // mat4.rotate(mvMatrix, degToRad(-90), [0, 1, 0]);
        //mat4.translate(mvMatrix, [-1, -1, zDir]);
		//if(Boolean(k1) == true){
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		//}
	
mat4.translate(mvMatrix, [xDir, pan, zDir]);
        mat4.translate(mvMatrix, [-11, -7, -15]);
        mat4.rotate(mvMatrix, degToRad(45), [0, 1, 0]);
				mat4.rotate(mvMatrix, degToRad(rotate), [0, 1, 0]);

    
		
			gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, HouseVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, HouseVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, HouseVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, HouseVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, HouseVertexIndexBuffer);
			gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[4]);
            setMatrixUniforms();	
            gl.drawElements(gl.TRIANGLES, HouseVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	//end house
	
	//start 2face
	
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
  		
			return;
        }
		
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
	
		mat4.translate(mvMatrix, [xDir, pan, zDir]);


        mat4.translate(mvMatrix, [x, -8, y]);
		
        mat4.rotate(mvMatrix, degToRad(180), [0, 1, 0]);
    				mat4.rotate(mvMatrix, degToRad(rotate), [0, 1, 0]);
		gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, faceVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, faceVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, faceVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, faceVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndexBuffer);
				gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[6]);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, faceVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

	//end 2face
		//start 2face2
		if(Boolean(walk1) == true){
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
  		
			return;
        }
			//window.alert(textures[2].image.src);
		
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
			//	if(Boolean(k1) == true){
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		//}
       // mat4.rotate(mvMatrix, degToRad(-90), [0, 1, 0]);
        //mat4.translate(mvMatrix, [-1, -7, zDir]);
		mat4.translate(mvMatrix, [xDir, pan, zDir]);


        mat4.translate(mvMatrix, [8, -56, -140]);
        mat4.rotate(mvMatrix, degToRad(180), [0, 1, 0]);
		gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, face2VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, face2VertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, face2VertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, face2VertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, face2VertexIndexBuffer);
				gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[6]);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, face2VertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}
	//end 2face2
		//start 2face3
if(Boolean(walk2) == true){		
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
  		
			return;
        }
			//window.alert(textures[2].image.src);
		
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
       	//if(Boolean(k1) == true){
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		//}
		mat4.translate(mvMatrix, [xDir, pan, zDir]);


        mat4.translate(mvMatrix, [8, -56, -140]);
        mat4.rotate(mvMatrix, degToRad(180), [0, 1, 0]);
		gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, face3VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, face3VertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, face3VertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, face3VertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, face3VertexIndexBuffer);
				gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[6]);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, face3VertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}
	//end 2face3
	
	//start pallet
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
            
			
			return;
        }
		
		
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, crateTextures[3]);
	mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
			//	if(Boolean(k1) == true){
			
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
	//	}
       // mat4.rotate(mvMatrix, degToRad(-90), [0, 1, 0]);
	   mat4.translate(mvMatrix, [0, -13, -18]);
				
 mat4.translate(mvMatrix, [xDir, pan, zDir]);
 mat4.rotate(mvMatrix, degToRad(rotate), [0, 1, 0]);
        //mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);
    
		
			gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, palletVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, palletVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, palletVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, palletVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, palletVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, palletVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	//end pallet
	
	
	//start din 
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
            
			
			return;
        }
		
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
				//if(Boolean(k1) == true){
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		//}
       // mat4.rotate(mvMatrix, degToRad(-90), [0, 1, 0]);
       // mat4.translate(mvMatrix, [-1, -10, zDir]);//camera
		mat4.translate(mvMatrix, [xDir, pan, zDir]);
        mat4.translate(mvMatrix, [-5, -9, -16]);
        mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);
		mat4.rotate(mvMatrix, degToRad(rotate), [0, 1, 0]);
    
		
			gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dinVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, dinVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, dinVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, dinVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dinVertexIndexBuffer);
			gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, crateTextures[5]);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, dinVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	//end din
	
	//start boat
	if (laptopVertexPositionBuffer == null || laptopVertexNormalBuffer == null || laptopVertexTextureCoordBuffer == null || laptopVertexIndexBuffer == null) {
            
			
			return;
        }
	;
	mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
				//if(Boolean(k1) == true){
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		//}
        //mat4.translate(mvMatrix, [-1, -1, zDir]);//camera  
mat4.translate(mvMatrix, [xDir, pan, zDir]);		
        mat4.translate(mvMatrix, [-15, -9, -10]);
        mat4.rotate(mvMatrix, degToRad(30), [0, 1, 0]);
		mat4.rotate(mvMatrix, degToRad(rotate), [0, 1, 0]);
    
		
			gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, boatVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, boatVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, boatVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boatVertexIndexBuffer);
			gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, crateTextures[2])
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, boatVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	//end boat 
	
	
	
	
	 Sx = 60.0, Sy = 60, Sz = 0.0;
     
     // Note: WebGL is column major order
     xformMatrix = new Float32Array([
        Sx, 0.0, 0.0, 0.0,
        0.0, Sy, 0.0, 0.0,
        0.0, 0.0, Sz, 0.0,
        0.0, 0.0, 0.0, 1.0
     ]);
	 
	 
        //gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	    //DRAWING BACKGROUND
		
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
		mat4.translate(mvMatrix, [xDir, pan, zDir]);
		
		
		mat4.translate(mvMatrix, [0.0, 0.0, -40.00]);// moving background
		mat4.rotate(mvMatrix, degToRad(180), [1, 0, 0]);//this moves background this flipped correctly
		mat4.multiply(mvMatrix, xformMatrix);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, crateTextures[7]);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
				//END drawing back ground

		
		//drawing floor
		mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	        mat4.identity(mvMatrix);
		
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);
	
		mat4.translate(mvMatrix, [xDir, pan, zDir]);
		mat4.translate(mvMatrix, [0.0, -10.0, -40.0]);// moving background		
		mat4.rotate(mvMatrix, degToRad(90), [1, 0, 0]);//this moves background this flipped correctly
		mat4.multiply(mvMatrix, xformMatrix);
		
        gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, floorVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[1]);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, floorVertexPositionBuffer.numItems);
		//END floor
		
		
		

		//DRAWING CUBE
			
        mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
				mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);

		mat4.translate(mvMatrix, [xDir, pan, zDir]);

        mat4.translate(mvMatrix, [6.0, -8.5, -10]);// z moves cube only items 

       // mat4.rotate(mvMatrix, degToRad(zDir), [1, 0, 0]);
       // mat4.rotate(mvMatrix, degToRad(yRot), [0, 1, 0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[2]);
 

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
//end cube

//start handles 

		function makeScale(sx, sy, sz) {
  return [
    sx, 0,  0,  0,
    0, sy,  0,  0,
    0,  0, sz,  0,
    0,  0,  0,  1,
  ];
}

//first handle
        mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);

		mat4.translate(mvMatrix, [xDir, pan, zDir]);
		mat4.translate(mvMatrix, [6.0, -7.0, -10]);// z moves cube only items 
		mat4.multiply(mvMatrix, makeScale(.1,.5,.1));
        
		
       // mat4.rotate(mvMatrix, degToRad(zDir), [1, 0, 0]);
       // mat4.rotate(mvMatrix, degToRad(yRot), [0, 1, 0]);
		if(Boolean(switch1) == true){
			mat4.rotate(mvMatrix, degToRad(45), [1, 0, 0]);
		}
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[5]);
 

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

		//SECOND handle
		    mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
	
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);

		mat4.translate(mvMatrix, [xDir, pan, zDir]);
		mat4.translate(mvMatrix, [6.5, -7.0, -10]);// z moves cube only items 
		mat4.multiply(mvMatrix, makeScale(.1,.5,.1));
		if(Boolean(switch2) == true){
			mat4.rotate(mvMatrix, degToRad(45), [1, 0, 0]);
		}
		if(Boolean(switch2) == true && Boolean(switch1) == true){
			document.getElementById("pos0").innerHTML = "BOOM!!...TNT exploded";
		}
		 gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[5]);
 

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
//end handles		
	
	//SECOND handle
		    mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
	
		mat4.rotate(mvMatrix, degToRad(rot), [0, 1, 0]);

		mat4.translate(mvMatrix, [xDir, pan, zDir]);
		mat4.translate(mvMatrix, [6.5, -7.0, -10]);// z moves cube only items 
		mat4.multiply(mvMatrix, makeScale(.1,.5,.1));
		if(Boolean(switch2) == true){
			mat4.rotate(mvMatrix, degToRad(45), [1, 0, 0]);
		}
		if(Boolean(switch2) == true && Boolean(switch1) == true){
			document.getElementById("pos0").innerHTML = "BOOM!!...TNT exploded";
		}
		 gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, crateTextures[5]);
 

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
//end handles	
	}


    var lastTime = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

           // teapotAngle += 0.05 * elapsed;
			 // xRot += (zDir * elapsed) / 1000.0;
			// zRot += zDir ;
			// xRot += xDir ;
            //yRot += (ySpeed * elapsed) / 1000.0;

        }
        lastTime = timeNow;
    }


    function tick() {
        requestAnimFrame(tick);
        handleKeys();

        drawScene();
        animate();
    }


    function webGLStart() {
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
	  initBuffers();

        initTextures();
		loadLaptop();
        loadTeapot();
		loadHouse();
		loadface();
		loadface2();
		loadface3();
		loadPallet();
		loadDin();
		loadboat();
				
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
   canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
   // document.onmousemove = handleMouseMove;
        tick();
    }

</script>


<style type="text/css">
    #loadingtext {
        position:absolute;
        top:250px;
        left:150px;
        font-size:2em;
        color: white;
    }
</style>


</head>


<body onload="webGLStart();">
   

    <canvas id="canvas" style="border: none;" width="1200" height="1000"></canvas>

    <div id="loadingtext">Loading world...</div>
    <br/>

    <input type="checkbox" id="specular" checked /> Show specular highlight<br/>
    <input type="checkbox" id="lighting" checked /> Use lighting<br/>

<button id="1" onClick="reply_click(this.id)">Cycle Views</button>
<button id="2" onClick="reply_click1(this.id)">Switch 1</button>

<button id="3" onClick="reply_click2(this.id)">Switch 2</button>



    <h2>Point light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightPositionX" value="-10.0" />
            <td>Y: <input type="text" id="lightPositionY" value="4.0" />
            <td>Z: <input type="text" id="lightPositionZ" value="-20.0" />
        </tr>
        <tr>
            <td><b>Specular colour:</b>
            <td>R: <input type="text" id="specularR" value="0.8" />
            <td>G: <input type="text" id="specularG" value="0.8" />
            <td>B: <input type="text" id="specularB" value="0.8" />
        </tr>
        <tr>
            <td><b>Diffuse colour:</b>
            <td>R: <input type="text" id="diffuseR" value="0.8" />
            <td>G: <input type="text" id="diffuseG" value="0.8" />
            <td>B: <input type="text" id="diffuseB" value="0.8" />
        </tr>
    </table>


    <h2>Ambient light:</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Colour:</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    <br/>
	<p>
	Arrow keys left and right move camera in x and y <br/>
	Arrow key up and down will move camera on z axis<br/>
	E and R key will make twoFace walk<br/>
	"Cycle Views" button will cycle through camera views<br/>
	B key does the top down view<br/>
	W, A, S, D will move two face
	</p>
	<p id="pos0"></p></br>
	<p>x position of two face</p>
	<p id="pos1"></p>
	<p>z position of two face</p>
	<p id="pos2"></p>
	


</body>

</html>
